import Foundation
//
//1. –°–æ–∑–¥–∞–π—Ç–µ —Ç–∏–ø –ö–æ–º–Ω–∞—Ç–∞. –£ –∫–æ–º–Ω–∞—Ç—ã –µ—Å—Ç—å —Ä–∞–∑–º–µ—Ä—ã W –Ω–∞ H. –ò —Å–æ–∑–¥–∞–π—Ç–µ —Ç–∏–ø –ü–µ—Ä—Å–æ–Ω–∞–∂. –£ –Ω–µ–≥–æ–µ—Å—Ç—å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ –≤ –∫–æ–º–Ω–∞—Ç–µ X –∏ Y. –†–µ–∞–ª–∏–∑—É–π—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é, –∫–æ—Ç–æ—Ä–∞—è –∫—Ä–∞—Å–∏–≤–µ–Ω—å–∫–æ —Ç–µ–∫—Å—Ç–æ–º –±—É–¥–µ—Ç –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å –ø–æ–ª–æ–∂–µ–Ω–∏–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ –≤ –∫–æ–º–Ω–∞—Ç–µ
//
//2. –ü–µ—Ä—Å–æ–Ω–∞–∂—É –¥–æ–±–∞–≤—å—Ç–µ –º–µ—Ç–æ–¥ –∏–¥—Ç–∏, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–∏–Ω–∏–º–∞–µ—Ç —ç–Ω—É–º—á–∏–∫ –ª–µ–≤–æ, –ø—Ä–∞–≤–æ, –≤–µ—Ä—Ö, –≤–Ω–∏–∑
//–≠—Ç–æ—Ç –º–µ—Ç–æ–¥ –¥–æ–ª–∂–µ–Ω –ø–µ—Ä–µ–¥–≤–∏–≥–∞—Ç—å –ø–µ—Ä—Å–æ–Ω–∞–∂–∞. –†–µ–∞–ª–∏–∑—É–π—Ç–µ –ø—Ä–∞–≤–∏–ª–æ —á—Ç–æ –ø–µ—Ä—Å–æ–Ω–∞–∂ –Ω–µ –¥–æ–ª–∂–µ–Ω –ø–æ–∫–∏–Ω—É—Ç—å –ø—Ä–µ–¥–µ–ª—ã –∫–æ–º–Ω–∞—Ç—ã. –ü–æ–¥–≤–∏–≥–∞–π—Ç–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ –∏ –ø–æ–∫–∞–∂–∏—Ç–µ —ç—Ç–æ –≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏
//

//3. –°–æ–∑–¥–∞—Ç—å —Ç–∏–ø –Ø—â–∏–∫. –£ —è—â–∏–∫–∞ —Ç–∞–∫–∂–µ –µ—Å—Ç—å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ –≤ –∫–æ–º–Ω–∞—Ç–µ X –∏ Y. –Ø—â–∏–∫ —Ç–∞–∫–∂–µ –Ω–µ –º–æ–∂–µ—Ç –ø–æ–∫–∏–¥–∞—Ç—å –ø—Ä–µ–¥–µ–ª—ã –∫–æ–º–Ω–∞—Ç—ã –∏ —è—â–∏–∫ —Ç–∞–∫–∂–µ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Ä–∞—Å–ø–µ—á–∞—Ç–∞–Ω –≤–º–µ—Å—Ç–µ —Å –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–º –≤ —Ñ—É–Ω–∫—Ü–∏–∏ –ø–µ—á–∞—Ç–∏.
//
//4. –¢–µ–ø–µ—Ä—å —Å–∞–º–æ–µ –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ–µ, –ø–µ—Ä—Å–æ–Ω–∞–∂ –º–æ–∂–µ—Ç –¥–≤–∏–≥–∞—Ç—å —è—â–∏–∫, –µ—Å–ª–∏ –æ–Ω —Å—Ç–æ–∏—Ç –Ω–∞ —Ç–æ–º –º–µ—Å—Ç–µ, –∫—É–¥–∞ –ø–µ—Ä—Å–æ–Ω–∞–∂ —Ö–æ—á–µ—Ç –ø–æ–ø–∞—Å—Ç—å. –ì–ª–∞–≤–Ω–æ–µ —á—Ç–æ –Ω–∏ –æ–¥–∏–Ω –æ–±—ä–µ–∫—Ç –Ω–µ –º–æ–∂–µ—Ç –ø–æ–∫–∏–Ω—É—Ç—å –ø—Ä–µ–¥–µ–ª—ã –∫–æ–º–Ω–∞—Ç—ã. –ü–æ–¥–≤–∏–≥–∞–π—Ç–µ —è—â–∏–∫ :)
//
//5. –î–æ–±–∞–≤—å—Ç–µ —Ç–æ—á–∫—É –≤ –∫–æ–º–Ω–∞—Ç–µ, –∫—É–¥–∞ –Ω–∞–¥–æ —è—â–∏–∫ –ø–µ—Ä–µ–¥–≤–∏–Ω—É—Ç—å –∏ –¥–≤–∏–≥–∞–π—Ç–µ :)

let image = ["‚¨ú","üòà","‚ùå","‚¨õ", "üéÅ"]

enum Moving{
    case up, down, right, left
}

struct EndPoint{
    var img = image[2]
    var x,y:Int
    
    init(x:Int, y:Int){
        self.x = x
        self.y = y
    }
}
struct Box{
    var img = image[4]
    var x:Int{
        didSet{
            if self.x < 1 || self.x >= room.Widht {
                self.x = oldValue
            }
        }
    }
    var y:Int{
        didSet{
            if self.y < 1 || self.y >= room.Hight {
                self.y = oldValue
            }
        }
    }
   

}
struct Room{
    var Widht:Int
    var Hight:Int
   
    init(Widht:Int, Hight:Int){
        self.Widht = Widht
        self.Hight = Hight
    }
}
var room = Room(Widht: 10, Hight: 10)
var box = Box(x: 5, y: 4)
var endPoint = EndPoint(x: 5, y: 3)
let victory = "You win"
struct Player{
    let img = image[1]
    var x:Int{
        didSet{
            if self.x < 1 || self.x >= room.Widht {
                self.x = oldValue
            }
        }
    }
    var y:Int{
        didSet{
            if self.y < 1 || self.y >= room.Hight {
                self.y = oldValue
            }
        }
    }
    init(x:Int,y:Int){
        self.x = x
        self.y = y
    }
    mutating func move(position:Moving){
        func checkBox()->Bool{return self.x == box.x && self.y == box.y}
        func checkEnd()->Bool{if box.x == endPoint.x && box.y == endPoint.y{
            box.img == endPoint.img
        }
        return true
        }
        switch position {
        case .up: self.y += 1 ; if checkBox(){box.y += 1};if checkBox(){self.y += 1}; if checkEnd(){print(victory)}
        case .down: self.y -= 1 ; if checkBox(){box.y -= 1};if checkBox(){self.y -= 1}; if checkEnd(){print(victory)}
        case .right: self.x += 1 ; if checkBox(){box.x += 1};if checkBox(){self.x += 1}; if checkEnd(){print(victory)}
        case .left: self.x -= 1 ; if checkBox(){box.x -= 1};if checkBox(){self.x -= 1}; if checkEnd(){print(victory)}
        }
    }
    mutating func playerPosition(position:Moving){
       
        switch position {
        case .down : x += 1
        case .up : x -= 1
        case .right : y += 1
        case .left : y -= 1
        }
    }
}
func game(_ player:Player, _ box:Box, _ endGame:EndPoint)->String{
    var map = ""
    for i in 0...room.Hight{
        for j in 0...room.Widht{
            switch (i,j) {
            case let(w,h) where w == player.x && h == player.y:map += player.img
            case let(w,h) where w == box.x && h == box.y:map += box.img
            case let(w,h) where w == endGame.x && h == endGame.y:map += endGame.img
            case let(w,h) where w == 0 || h == 0 || h == room.Hight || w == room.Widht: map += image[3]
            default: map += image[0]
            }
        }
        map += "\n"
    }
    return map
}

var player = Player(x: 5, y: 5)


player.playerPosition(position: .down)
player.playerPosition(position: .up)
player.playerPosition(position: .left)
player.playerPosition(position: .left)

var g = game(player, box, endPoint)
print(g)





//–®–∞—Ö–º–∞—Ç–Ω–∞—è –¥–æ—Å–∫–∞ (–õ–µ–≥–∫–∏–π —É—Ä–æ–≤–µ–Ω—å)
//
//1. –°–æ–∑–¥–∞–π—Ç–µ —Ç–∏–ø —à–∞—Ö–º–∞—Ç–Ω–∞—è –¥–æ—Å–∫–∞.
//
//2. –î–æ–±–∞–≤—å—Ç–µ —Å–∞–±—Å–∫—Ä–∏–ø—Ç, –∫–æ—Ç–æ—Ä—ã–π –≤—ã–¥–∞–µ—Ç —Ü–≤–µ—Ç –∫–ª–µ—Ç–∫–∏ –ø–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–µ –∫–ª–µ—Ç–∫–∏ (–±—É–∫–≤–∞ –∏ —Ü–∏—Ñ—Ä–∞).
//
//3. –ï—Å–ª–∏ —é–∑–µ—Ä –æ—à–∏–±—Å—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º–∏ - –≤—ã–¥–∞–≤–∞–π—Ç–µ –Ω–∏–ª
//

struct Chess{
    enum Color:String{
        case color1 = "‚¨õ"
        case color2 = "‚¨ú"
    }
    static var dict = ["A": 1,"B":2, "C":3,"D":4,"E":5, "F":6,"G":7,"H":8]
    subscript(colomn:String, row:Int)->String?{
        var map:String?
        if Chess.dict[colomn.capitalized] != nil && row <= Chess.dict.count{
            map = Chess.dict[colomn.capitalized] ?? 0 % 2 == row % 2 ? Color.color1.rawValue : Color.color2.rawValue
        }else {
            return ""
        }
        return map
    }
        
}

var chess = Chess.init()
print(chess["A",5]!)
print(chess["C",5]!)
print(chess["A",6]!)

//–ö—Ä–µ—Å—Ç–∏–∫–∏ –Ω–æ–ª–∏–∫–∏ (–°—Ä–µ–¥–Ω–∏–π —É—Ä–æ–≤–µ–Ω—å)
//
//1. –°–æ–∑–¥–∞—Ç—å —Ç–∏–ø, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—â–∏–π —Å–æ–±–æ–π –ø–æ–ª–µ –¥–ª—è –∏–≥—Ä—ã –≤ –∫—Ä–µ—Å—Ç–∏–∫–∏ –Ω–æ–ª–∏–∫–∏
//–ù–∞ –∫–∞–∂–¥–æ–π –∫–ª–µ—Ç–∫–µ –º–æ–∂–µ—Ç –±—ã—Ç—å —Ç–æ–ª—å–∫–æ –æ–¥–Ω–æ –∏–∑ –∑–Ω–∞—á–µ–Ω–∏–π: –ü—É—Å—Ç–æ, –ö—Ä–µ—Å—Ç–∏–∫, –ù–æ–ª–∏–∫
//–î–æ–±–∞–≤—å—Ç–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∫—Ä–∞—Å–∏–≤–æ —Ä–∞—Å–ø–µ—á–∞—Ç—ã–≤–∞—Ç—å –ø–æ–ª–µ
//
//2. –î–æ–±–∞–≤—å—Ç–µ —Å–∞–±—Å–∫—Ä–∏–ø—Ç, –∫–æ—Ç–æ—Ä—ã–π —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –∫–ª–µ—Ç–∫–∏ –ø–æ —Ä—è–¥—É –∏ —Å—Ç–æ–ª–±—Ü—É,
//–ø—Ä–∏—á–µ–º –≤—ã –¥–æ–ª–∂–Ω—ã —Å–ª–µ–¥–∏—Ç—å –∑–∞ —Ç–µ–º, —á—Ç–æ–±—ã –ø—Ä–æ–≥—Ä–∞–º–º–∞ –Ω–µ –ø–∞–¥–∞–ª–∞ –µ—Å–ª–∏ –±—É–¥–µ—Ç –≤–≤–µ–¥–µ–Ω –Ω–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —Ä—è–¥ –∏–ª–∏ —Å—Ç–æ–ª–±–µ—Ü.
//
//3. –¢–∞–∫–∂–µ —Å–ª–µ–¥–∏—Ç–µ –∑–∞ —Ç–µ–º, —á—Ç–æ–±—ã –Ω–µ–ª—å–∑—è –±—ã–ª–æ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—Ç—å –∫—Ä–µ—Å—Ç–∏–∫ –ª–∏–±–æ –Ω–æ–ª–∏–∫ —Ç—É–¥–∞, –≥–¥–µ –æ–Ω–∏ —É–∂–µ —á—Ç–æ-—Ç–æ –µ—Å—Ç—å. –î–æ–±–∞–≤—å—Ç–µ –º–µ—Ç–æ–¥ –æ—á–∏—Å—Ç–∫–∏ –ø–æ–ª—è.
//
//4. –ï—Å–ª–∏ —Ö–æ—Ç–∏—Ç–µ, –¥–æ–±–∞–≤—Ç–µ –∞–ª–≥–æ—Ä–∏—Ç–º, –∫–æ—Ç–æ—Ä—ã–π –≤—ã—á–∏—Å–ª–∏—Ç –ø–æ–±–µ–¥–∏—Ç–µ–ª—è
//

//–ú–æ—Ä—Å–∫–æ–π –±–æ–π (–¢—è–∂–µ–ª—ã–π —É—Ä–æ–≤–µ–Ω—å)
//
//1. –°–æ–∑–¥–∞–π—Ç–µ —Ç–∏–ø –∫–æ—Ä–∞–±–ª—å, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—Ç—å —Å–æ–±–æ–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫. –í –Ω–µ–º –º–æ–∂–µ—Ç –±—ã—Ç—å –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ–¥–Ω–æ–º–µ—Ä–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç (–ø–æ–ø–∞—Ö–∏–≤–∞–µ—Ç —Å–∞–±—Å–∫—Ä–∏–ø—Ç–æ–º). –ö–æ—Ä–∞–±–ª—å –¥–æ–ª–∂–µ–Ω –ø—Ä–∏–Ω–∏–º–∞—Ç—å –≤—ã—Å—Ç—Ä–µ–ª—ã –ø–æ –ª–æ–∫–∞–ª—å–Ω—ã–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞–º –∏ –≤—ã—á–∏—Å–ª—è—Ç—å –∫–æ–≥–¥–∞ –æ–Ω —É–±–∏—Ç
//
//2. –°–æ–∑–¥–∞–π—Ç–µ –¥–≤—É–º–µ—Ä–Ω–æ–µ –ø–æ–ª–µ, –Ω–∞ –∫–æ—Ç–æ—Ä–æ–º –±—É–¥—É—Ç —Ä–∞—Å–ø–æ–ª–∞–≥–∞—Ç—å—Å—è –∫–æ—Ä–∞–±–ª–∏ –≤—Ä–∞–≥–∞. –°—Ç—Ä–µ–ª—è–π—Ç–µ –ø–æ –ø–æ–ª—é –∏ –ø–æ–¥–±–µ–π—Ç–µ –≤—Ä–∞–∂–µ—Å–∫–∏–π —á–µ—Ç—ã—Ä–µ—Ö —Ç—Ä—É–±–Ω–∏–∫ :)
//
//3. –°–¥–µ–ª–∞–π—Ç–µ –¥–ª—è –ø—Ä–∏–ª–∏—á–∏—è –ø–∞—Ä—É –≤—ã—Å—Ç—Ä–µ–ª–æ–≤ –º–∏–º–æ, –∫—Ä–∞—Å–∏–≤–µ–Ω—å–∫–æ –≤—Å–µ –≤—ã–≤–æ–¥–∏—Ç–µ –Ω–∞ —ç–∫—Ä–∞–Ω :)
